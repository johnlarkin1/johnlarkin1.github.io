<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.7.1 --><title>Localization with a Particle Filter | Where will you go next?</title><meta name="generator" content="Jekyll v3.9.1" /><meta property="og:title" content="Localization with a Particle Filter" /><meta name="author" content="johnlarkin1" /><meta property="og:locale" content="en_US" /><meta name="description" content="A visualization of how a particle filter can help you locate your robot in a maze… Or just what a particle filter is." /><meta property="og:description" content="A visualization of how a particle filter can help you locate your robot in a maze… Or just what a particle filter is." /><link rel="canonical" href="http://localhost:4000/2016/particle-filter/" /><meta property="og:url" content="http://localhost:4000/2016/particle-filter/" /><meta property="og:site_name" content="Where will you go next?" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-12-31T00:00:00-08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Localization with a Particle Filter" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"johnlarkin1"},"@type":"BlogPosting","description":"A visualization of how a particle filter can help you locate your robot in a maze… Or just what a particle filter is.","headline":"Localization with a Particle Filter","dateModified":"2016-12-31T00:00:00-08:00","datePublished":"2016-12-31T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2016/particle-filter/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/images/mountain.png"},"name":"johnlarkin1"},"url":"http://localhost:4000/2016/particle-filter/","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/icons/apple-touch-icon.png?v=qA3OXqyw77"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/icons/favicon-32x32.png?v=qA3OXqyw77"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/icons/favicon-16x16.png?v=qA3OXqyw77"><link rel="manifest" href="/assets/img/icons/manifest.json?v=qA3OXqyw77"><link rel="mask-icon" href="/assets/img/icons/safari-pinned-tab.svg?v=qA3OXqyw77" color="#5bbad5"> <!--[if IE]><link rel="shortcut icon" href="/assets/img/icons/favicon.ico?v=qA3OXqyw77"><![endif]--><link rel="shortcut icon" href="/assets/img/icons/favicon.ico?v=qA3OXqyw77"><meta name="apple-mobile-web-app-title" content="Sleek"><meta name="application-name" content="Sleek"><meta name="msapplication-config" content="/assets/img/icons/browserconfig.xml?v=qA3OXqyw77"><meta name="theme-color" content="#ffffff"> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-KDHGNV6"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'GTM-KDHGNV6'); </script><style class="inlineCSS"> h1{color:#313237;margin-top:0;margin-bottom:.5rem}.dark-bg{background-color:#313237}@media only screen and (min-width:48em){.post-card{width:48.4375%;margin-right:3.125%}.post-card:last-of-type,.post-card:nth-child(2n+2){margin-right:0}}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figure,main{display:block}figure{margin:1em 40px}a{background-color:transparent;-webkit-text-decoration-skip:objects}img{border-style:none}svg:not(:root){overflow:hidden}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}body{-webkit-overflow-scrolling:touch}*,::after,::before{-webkit-box-sizing:inherit;box-sizing:inherit}.site{display:-webkit-box;display:-ms-flexbox;display:flex;min-height:100vh;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.site__content{-webkit-box-flex:1;-ms-flex:1;flex:1}img{max-width:100%;height:auto;width:auto;vertical-align:middle}figure{margin:0}body{background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Hiragino Sans GB","Microsoft YaHei","WenQuanYi Micro Hei",sans-serif;font-size:1rem;line-height:1.5;color:#343851;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%}p{margin-top:0;margin-bottom:1.25rem}h1,h2{color:#313237;margin-top:0;margin-bottom:.5rem}a{color:#277cea;text-decoration:none;border-bottom:1px dashed #277cea}.blur{background:#fff;filter:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg"><filter id="filter"><feGaussianBlur stdDeviation="16" /></filter></svg>#filter');-webkit-filter:blur(1rem);filter:blur(1rem)}.container{padding:0 20px;max-width:100%;margin:0 auto}@media only screen and (min-width:36em){.container{max-width:540px;margin:0 auto}}@media only screen and (min-width:48em){.container{max-width:720px;margin:0 auto}}@media only screen and (min-width:62em){.container{max-width:960px;margin:0 auto}}@media only screen and (min-width:75em){.container{max-width:1170px;margin:0 auto}}.header{background-color:#fff;color:#343851;position:absolute;z-index:4;width:100%;top:0;left:0;will-change:transform;-webkit-transform:translateY(0);transform:translateY(0)}.header a{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-bottom:0}.header__logo{display:-webkit-box;display:-ms-flexbox;display:flex;height:100%;overflow:hidden;padding:19px 0;margin-right:1.25rem;outline:0;border-bottom:0;color:#313237}.header__logo .header__logo--container{width:58px}.header__logo .header__logo--container .logo{fill:currentColor}.header__inner{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:3.75em;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.header__links{padding-bottom:.5rem;display:none;position:absolute;top:3.75em;left:0;width:100%;height:auto;background:#fff}.header__link{color:#343851;padding:.938rem 0;border-top:1px solid #ededed}.header__toggle{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:44px;height:100%;background-color:transparent;padding-left:1.25rem}.header__toggle span{display:block;position:relative;margin-top:4px;background-color:#343851;width:100%;height:2px;border-radius:1px}.header__toggle span:first-child{margin-top:0}@media (min-width:62em){.header__toggle{display:none;visibility:hidden}.header__links{position:static;padding:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;visibility:visible;width:auto;height:100%}.header__links-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;height:100%;padding:0}.header__link{position:relative;padding:.938rem 1rem;border:0;height:100%}.header__link::after{content:"";display:block;position:absolute;left:0;bottom:0;height:3px;width:100%;-webkit-transform:scaleX(0);transform:scaleX(0);background:#277cea}}.post-card{display:block;position:relative;width:100%;min-height:250px;border-radius:4px;overflow:hidden;background-color:#fff;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.08);box-shadow:0 1px 3px rgba(0,0,0,.08);margin-bottom:2.25rem;border-bottom:0}@media only screen and (min-width:48em){.post-card{width:48.4375%;margin-right:3.125%}.post-card:nth-child(2n+2){margin-right:0}}@media only screen and (min-width:75em){.post-card{width:31.25%;margin-right:3.125%}.post-card:nth-child(2n+2){margin-right:3.125%}}.post-card__label{position:absolute;top:1.5rem;left:1.5rem;z-index:2}.post-card__inner{display:block;position:relative;padding:1.875rem 1.25rem .625rem;width:100%;color:#838c8d;border-bottom:0}.post-card__header{margin-bottom:.75rem}.post-card__meta{font-size:.875rem}.post-card__thumb{margin:0;background:#fff;position:relative;overflow:hidden}.post-card__thumb::after{content:"";display:block;height:0;width:100%;padding-bottom:56.25%}.post-card__thumb>*{position:absolute;top:0;left:0;width:100%;height:100%;display:block}.label{padding:0 10px;margin-bottom:1rem;display:inline-block;line-height:20px;font-size:.75rem;text-transform:uppercase;letter-spacing:1px;color:rgba(255,255,255,.8);border:2px solid rgba(255,255,255,.5);border-radius:100px}.hero{margin:3.75rem auto 0;min-height:16.25rem;width:100%;position:relative;background-color:#dde5ea;background-repeat:no-repeat;background-position:50%;background-size:cover}@media only screen and (min-width:62em){.hero{margin:0 auto;height:36em}}.hero::before{position:absolute;display:block;content:"";top:0;left:0;width:100%;height:100%;background:rgba(52,56,81,.8)}.hero__wrap{position:absolute;margin:auto;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);text-align:center;color:rgba(255,255,255,.8);width:100%;max-width:90%;z-index:1}.hero__wrap .hero__title{font-size:1.8em;color:#fff}.blog{background-color:#f9f9f9}.post-list{padding-top:2.5em;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}@media only screen and (min-width:48em){.hero__wrap{max-width:40em}.hero__wrap .hero__title{padding:1rem 0;font-size:2.625em;line-height:3.125rem}.post-list{padding-top:5em}}</style><link rel="preload" href="/assets/css/main.css" as="style" onload="this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css"></noscript> <script type="text/javascript"> /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */ (function(w){"use strict";if(!w.loadCSS){w.loadCSS=function(){}} var rp=loadCSS.relpreload={};rp.support=(function(){var ret;try{ret=w.document.createElement("link").relList.supports("preload")}catch(e){ret=!1} return function(){return ret}})();rp.bindMediaToggle=function(link){var finalMedia=link.media||"all";function enableStylesheet(){link.media=finalMedia} if(link.addEventListener){link.addEventListener("load",enableStylesheet)}else if(link.attachEvent){link.attachEvent("onload",enableStylesheet)} setTimeout(function(){link.rel="stylesheet";link.media="only x"});setTimeout(enableStylesheet,3000)};rp.poly=function(){if(rp.support()){return} var links=w.document.getElementsByTagName("link");for(var i=0;i<links.length;i++){var link=links[i];if(link.rel==="preload"&&link.getAttribute("as")==="style"&&!link.getAttribute("data-loadcss")){link.setAttribute("data-loadcss",!0);rp.bindMediaToggle(link)}}};if(!rp.support()){rp.poly();var run=w.setInterval(rp.poly,500);if(w.addEventListener){w.addEventListener("load",function(){rp.poly();w.clearInterval(run)})}else if(w.attachEvent){w.attachEvent("onload",function(){rp.poly();w.clearInterval(run)})}} if(typeof exports!=="undefined"){exports.loadCSS=loadCSS} else{w.loadCSS=loadCSS}}(typeof global!=="undefined"?global:this)) </script></head><body class="site"> <!-- Google Tag Manager (noscript) --> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KDHGNV6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <!-- End Google Tag Manager (noscript) --><header class="header" itemscope itemtype="http://schema.org/SiteNavigationElement" aria-label="Main navigation"><div class="container"><div class="header__inner"> <a class="header__logo" href="/"><div class="header__logo--container"> <svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 294.779 205.349"><defs><style>.cls-1{fill:#fff;}.cls-2{font-size:28px;font-family:Roboto-Medium, Roboto;font-weight:500;}</style></defs><path d="M177.284,200.364a80.333,80.333,0,0,0-16.5,6c-7.8,3.9-11,6.2-18.1,13.3-13.9,14-20.2,29.2-20.3,49.1-.1,12.8,1.3,18.7,7,30.8,14,29.2,47.8,45.1,78.9,37.2,14.7-3.8,29-13.2,44-29.2l7.5-8,7.5,8c15,16,29.3,25.4,44,29.2,36.3,9.3,74.5-13.9,84.2-51,2.3-8.7,2.3-25.3,0-34a95.883,95.883,0,0,0-5.9-15c-7.7-15.8-24.3-29.6-42.2-35.2-8.1-2.5-22.4-3.4-31.1-1.9-15.9,2.8-33.4,12.5-48.4,26.8l-8.2,7.9-8.1-7.9C228.184,203.964,203.384,195.164,177.284,200.364Z" transform="translate(-112.404 -133.469)"/><path class="cls-1" d="M348.384,203.264c19.3,6.4,32.8,18.5,41.5,37,5.9,12.7,7.6,25.5,4.6,34.1-5.4,15.2-15,23.1-32.5,27-8.8,2-28.4,1.5-34.7-.8l-3.9-1.5,5.4-.7c24.7-3.2,35.2-32.1,18.2-50a34.28,34.28,0,0,0-17.9-9.2c-9-1.3-20,5-34.7,20.1l-8.1,8.3-8.1-10.1c-4.5-5.6-10.3-12.8-12.9-16l-4.8-5.8,5.9-6c14.7-15,32.2-25.2,49.5-28.9C323.684,199.164,339.684,200.364,348.384,203.264Z" transform="translate(-112.404 -133.469)"/><path class="cls-1" d="M184.684,227.864a58.838,58.838,0,0,1,21.5,13c3.6,3.3,6.5,6.4,6.4,6.7-.1.4,4.2,5.1,9.5,10.4,5.3,5.4,9.7,10.2,9.7,10.6,0,1.6-11.9,14-18.3,19-9.4,7.4-14.1,9.6-21,9.5-20-.3-33.2-22.4-24.3-40.7,7.8-16,28.2-20.9,40.9-9.8.9.8,2,1.2,2.3.9,1-1-8.1-6.3-13.1-7.7-11.1-3.1-25.7,4.6-31.6,16.8-3.2,6.7-3.2,17.8.1,24.6,5.9,12.2,20.3,19.7,31.7,16.7,6.3-1.7,15.9-8.7,25.8-18.7l9-9.1,9.5,10.4c5.2,5.7,11,12.2,12.9,14.4l3.4,3.9-9.4,9.6c-16.6,16.9-29.3,24.9-44.9,28-38.4,7.7-75.4-19.2-81-58.8-2.3-16.1,3.1-33.1,13.4-42,2.8-2.4,10.1-6.2,15.1-7.8C160.884,224.964,175.784,224.964,184.684,227.864Z" transform="translate(-112.404 -133.469)"/><path class="cls-1" d="M338.484,243.364c9.8,4.7,15.5,13.9,15.5,25.4,0,11.6-5.6,20.6-15.9,25.6-12.8,6.3-22.9,2.7-40-14.2-5.7-5.6-10.3-10.7-10.3-11.4,0-2.1,19.3-20.3,25.3-23.9C322.684,239.264,328.884,238.864,338.484,243.364Z" transform="translate(-112.404 -133.469)"/><text class="cls-2" transform="translate(0 55.323)">Where will you go next?</text><text x="-112.404" y="-133.469"/></svg></div></a><nav class="header__links"><div class="container header__links-wrapper"> <a class="header__link" href="/" itemprop="url"> <span itemprop="name">Home</span> </a> <a class="header__link" href="/about" itemprop="url"> <span itemprop="name">About</span> </a> <a class="header__link" href="/categories" itemprop="url"> <span itemprop="name">Categories</span> </a> <a class="header__link" href="/contact" itemprop="url"> <span itemprop="name">Contact</span> </a></div></nav><div class="header__toggle"> <span></span> <span></span> <span></span></div></div></div></header><div class="hero lazyload" data-bg="http://localhost:4000/assets/img/posts/particle-light.jpg"><div class="hero__wrap"><div class="hero__categories"> <a class="label" href="/categories/#Algorithms">Algorithms</a> &nbsp; <a class="label" href="/categories/#Development">Development</a></div><h1 class="hero__title">Localization with a Particle Filter</h1><p class="hero__meta"> <span> <time>31 Dec 2016</time>&nbsp;&middot; </span> <span> 17 mins read </span></p></div></div><main class="site__content"><div class="container"><article class="post-content" itemprop="articleBody"><p>A visualization of how a particle filter can help you locate your robot in a maze… Or just what a particle filter is.</p><p>How do we find a lost robot? Well, one method is to use a particle filter to localize the position in a given world.</p><h1 id="background">Background</h1><p>This was a project that myself, and <a href="https://www.linkedin.com/in/tom-wilmots-030781a6">Tom Wilmots</a> (who is/was also a great basketball player, see <a href="http://swarthmoreathletics.com/roster.aspx?rp_id=2811">here</a>) and <a href="https://www.linkedin.com/in/ursula-monaghan-57086489">Ursula Monaghan</a> (who is also a great field hockey player, see <a href="http://www.swarthmoreathletics.com/roster.aspx?rp_id=3418&amp;path=fhockey">here</a>), worked on for our <a href="http://www.swarthmore.edu/NatSci/mzucker1/e28_f2016/index.html">E28 Mobile Robotics</a> final project. The class was taught by <a href="http://www.swarthmore.edu/NatSci/mzucker1/index.html">Matt Zucker</a>. You can see some of his work on his <a href="https://mzucker.github.io/">blog</a>. Again, if you’re not interested in reading any of this, you can just grab the <a href="https://github.com/johnlarkin1/particle-filter">code here</a>. However, particle filters are a little more complex than like a <a href="https://github.com/johnlarkin1/sudoku-solver">sudoku solver</a>, so it might be helpful to read some of this!</p><p>Matt phrased the final project as such:</p><blockquote><p>In lieu of a final exam, we will have a final project. The final project topic is open-ended, but it must strongly relate to robotics, and it must involve a substantial programming effort.</p><p>Each group will give a brief presentation of their project during our scheduled final exam slot on 12/15 from 9AM-12PM.</p></blockquote><p>He also made a few project suggestions, one of which was constructing a particle filter to localize our robot, Leela.</p><p>All semester we had been working with <a href="http://www.turtlebot.com/">TurtleBots</a>, which are essentially glorified Roombas. Totally kidding - Leela was great most of the time. Here’s a video of Leela nudging backwards from a wall. She was still a little jerky then.</p><center> <iframe title="YouTube video player" width="480" height="390" src="/videos/particle-filter/leela.m4v" frameborder="0" allowfullscreen=""></iframe> </center><p>Essentially, she’s a humanoid robot.</p><h1 id="theory-behind-particle-filter">Theory Behind Particle Filter</h1><h3 id="generally">Generally</h3><p>Much of this blog post is going to focus on particle filters with respects to robotics. More generally however, particle filters have many applications and uses. Computationally, it is a form of a genetic algorithm, with particles being scattered around, and then weights being given to said particles, and then sampling in accordance with those weights.</p><p>Historically, particle filters belong to the subclass of <a href="https://en.wikipedia.org/wiki/Evolutionary_computation">evolutinary computing</a>, which is a subfield of artificial intelligence. Particle filters even trace back further to the larger field of <a href="https://en.wikipedia.org/wiki/Mean_field_particle_methods">mean field particle methods</a>. These are a type of Monte Carlo algorithms that are known for satisfying a nonlinear evolution equation. Essentially, this means the updating of the particles is not linear in the sense that <strong>often</strong> it is random and unpredictable because it depends on the sampling drawn. The big thing to take away here is that there is <strong>sequential interacting samples</strong>, meaning each of the particles, “interacts with the emperical measures of the process”, as <a href="https://en.wikipedia.org/wiki/Mean_field_particle_methods">Wikipedia</a> would say.</p><p>This type of computing technique is actually, almost unsurprisingly, traced back to Alan Turing in the early 1950’s. Just a fun fact.</p><h3 id="robotics">Robotics</h3><p>So in theory, the particle filter is a way to localize your position in a given world, in linear time. This is a big ramp up from a Bayes Filter, which mantains a probability distribution over the entire search space and then updates with a motion and measurement model. This is how we were introduced to it in Mobile Robotics. So then the particle filter is a little bit more clever than the Bayes filter. It’s going to spread particles throughout your maze or map. You can think about these particles as almost baby robots. Then we’re going to get a command, and move all of our particles accordingly, take a measurement around, and give each particle a weight. Then, we resample our particles using those weights as the way to resample. <em>Eventually</em>, if we do a good job with our measurement update and we also do a good job scattering our particles initially, the particles should converge to some degree around the actual position of our robot.</p><h1 id="particle-filter-algorithm">Particle Filter Algorithm</h1><p>We can really think about this process as occuring in two steps, as <a href="http://www.swarthmore.edu/NatSci/mzucker1/index.html">Matt</a> laid out in class.</p><p>The base starting point is we start with \(n\) particles drawn from some initial distribution. This could be uniform over the entire maze, or some other configuration.</p><p>In other words, \(P = \{ x_1, x_2, ... x_{n-1}, x_n \}\) where \(x_i\) is a state in our space.</p><h3 id="1-motion-update">1. Motion Update</h3><p><em>Note, the particle filter <strong>samples</strong> the motion model.</em> The motion update is relatively simple. We just move each particle from a given command. Let’s call this command \(u\).<br /> So:</p>\[P' = \{x_1', x_2', ..., x_n' \}\]<p>where each \(x_i\) is sampled from \(P(x_i ' \mid x_i , u )\).</p><h3 id="2-measurement-update">2. Measurement Update</h3><p><em>Note, the particle filter <strong>evaluates</strong> the measurement model.</em> The measurement update is a little bit more complex. We have to observe our measurement and then we want to know the probability of actually being at such a point. The tricky part is we have to do this for each \(x_i '\) or for each particle. Mathematically speaking, this looks like:</p>\[w_i = \eta \cdot p(z \mid x_i)\]<p>where \(\eta\) is the normalizing factor here. So \(\eta = \frac{1}{\sum p(z \mid x_i) }\) . The \(w\)’s are the corresponding weights that result from the measurement model PDF.</p><p>But what do these weights mean? They are like little probabilities essentially. So \(w_i\) is the probability that \(x_i '\) is a “good particle”. The good particles are going to align well with the sensor measurements that were reported.</p><p>Then! We <strong>resample</strong>! We assemble \(P = \{ x_1, x_2, ..., x_{n-1}, x_n \}\) by sampling with replacement each \(x_i\) from \(P'\) with probability \(w_i\).</p><p>And that’s pretty much it! After this, we just repeat. It’s like a darwinistic approach. So just think about only the best particles from each generation are surviving.</p><p>For more information about particle filters, <a href="https://en.wikipedia.org/wiki/Particle_filter">Wikipedia</a> always does a pretty good job.</p><h1 id="raytracer">Raytracer</h1><p>So in order to get our expected distances, we need to set up a raytracer for our robot. This is how we’re going to get our measurements and evaluate each particle’s position. We can imagine our particle is going look around in the world and we’re going to compare that with the real robot’s perspective as well. If there is a lot of overlap, then the weight is going to be high, because the probability of the robot actually being where the particle is, is also going to be high.</p><p>Let’s look at some excerpts of the code.</p><p>We have constructed a ray class. It has an origin and direction, both of which are vectors. This is going to be helpful for finding the distance between two rays. That’s the critical problem - in order to find the expected distance, we have our walls (which we constructed as rays), and we have our robot/particle which is shooting out a bunch of rays.</p><p>So let’s look at the problem at hand. How do we find the distance between two vectors (and yes, I’m aware that I drew the wall as a line segment, but we wrote the code like a vector)?</p><p><img src="/images/particle-filter/dist_bn_vec.png" alt="vec_distances" class="center-super-shrink" /></p><p>For reference, let’s take the above as our diagram.</p><p>We can represent the following:</p><p>\begin{align} p_i &amp;= p_0 + \alpha \vec{d} \\ p_i &amp;= p_1 + \beta (p_2 - p_1) \end{align}</p><p>Let’s rename this vector between \(p_2\) and \(p_1\), as \(\vec{k}\). In other words, \(\vec{k} = p_2 - p_1\)</p><p>Then, we can have,</p><p>\begin{align} p_i &amp;= p_0 + \alpha \vec{d} \\ p_i &amp;= p_1 + \beta (p_2 - p_1) = p_1 + \beta \vec{k} \end{align}</p><p>Then we can relate the two through \(p_i\).</p><p>\begin{align} p_1 + \beta \vec{k} &amp;= p_0 + \alpha \vec{d} \\ \alpha \vec{d} - \beta \vec{k} &amp;= p_1 - p_0 \end{align}</p><p>Thus relating these in matrix-vector notation.</p>\[\left[ \begin{array}{c|c} \vec{\mathbf{d}} &amp; -\vec{\mathbf{k}} \end{array} \right] = \left[ \begin{array}{c} \alpha \\ \beta \end{array} \right] = \left[ \begin{array}{c} p_1 \\ -p_0 \end{array} \right]\]<p>Note, that \(\vec{b}\) and \(\vec{k}\) are actually of shape \(2 \times 1\) as they live in \(\mathbb{R}^2\), therefore the dimensinoality of this will work out. Also note, that we only care about when \(\beta\) lies in the range from [0,1]. If \(\beta\) is not in this range, than we can conclude that there is not a valid intersection. It means that it is not hitting this segment of the wall. We parametrized along our wall with the starting point at \(\beta = 0\) and the ending point at \(\beta = 1\).</p><p>With this matrix math set up, we know \(\vec{d}\) and we know \(\vec{k}\). There’s a <em>bunch</em> of different ways that we could solve this problem. We just obviously utilized <code class="language-plaintext highlighter-rouge">numpy</code>’s nice built in solver. Specifically, this problem of finding the distance between our robot and the wall segment was really solved by the following short method:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_xsection_bn_seg_and_ray</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">wall_segment</span><span class="p">):</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">wall_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">wall_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">starting_pt</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ending_pt</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 

    <span class="n">k</span> <span class="o">=</span> <span class="n">ending_pt</span> <span class="o">-</span> <span class="n">starting_pt</span> 
    <span class="n">k_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">.</span><span class="n">getx</span><span class="p">(),</span> <span class="n">k</span><span class="p">.</span><span class="n">gety</span><span class="p">()])</span>
    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">getx</span><span class="p">(),</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">gety</span><span class="p">()])</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">d_vec</span><span class="p">,</span> <span class="o">-</span><span class="n">k_vec</span><span class="p">])</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span>
    
    <span class="n">temp</span> <span class="o">=</span> <span class="n">starting_pt</span> <span class="o">-</span> <span class="n">p0</span>
    <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">temp</span><span class="p">.</span><span class="n">getx</span><span class="p">(),</span> <span class="n">temp</span><span class="p">.</span><span class="n">gety</span><span class="p">()])</span>

    <span class="n">a_b_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">p_vec</span><span class="p">)</span> 
</code></pre></div></div><h1 id="code">Code</h1><p>The rest of the code is largely about just iterating over through the particles and calculating the probability and then picking from subsequent probabilities. That’s where the real meat of the particle filter really comes into play. The rest is just making sure that we’re picking the right particle and visualizing everything appropriately.</p><p>I will show the measurement and motion update below, but the rest of the code can once again be found <a href="https://github.com/johnlarkin1/particle-filter">here</a>. Feel free to give it a run yourself!</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This is our motion update.
</span><span class="k">def</span> <span class="nf">motion_update</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">sigma_xy</span><span class="p">,</span> <span class="n">sigma_theta</span><span class="p">):</span>
    <span class="n">nparticles</span> <span class="o">=</span> <span class="n">particles</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># how many particles do we have
</span>    <span class="n">noisex</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span> <span class="o">=</span> <span class="n">sigma_xy</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nparticles</span><span class="p">)</span> <span class="c1"># noise for x
</span>    <span class="n">noisey</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span> <span class="o">=</span> <span class="n">sigma_xy</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nparticles</span><span class="p">)</span> <span class="c1"># noise for y
</span>    <span class="n">thetanoise</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span> <span class="o">=</span> <span class="n">sigma_theta</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nparticles</span><span class="p">)</span> <span class="c1"># noise for theta
</span>    <span class="k">if</span> <span class="n">control</span> <span class="o">==</span> <span class="s">"forward"</span><span class="p">:</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">FT</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span> <span class="o">+</span> <span class="n">noisex</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">FT</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span> <span class="o">+</span> <span class="n">noisey</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">thetanoise</span>
    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s">"backward"</span><span class="p">:</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">-=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">FT</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span> <span class="o">+</span> <span class="n">noisex</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">-=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">FT</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span> <span class="o">+</span> <span class="n">noisey</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">thetanoise</span>
    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s">"turnleft"</span><span class="p">:</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">noisex</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">noisey</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mi">90</span><span class="o">*</span><span class="n">DEG</span> <span class="o">+</span> <span class="n">thetanoise</span>
    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s">"turnright"</span><span class="p">:</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">noisex</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">noisey</span>
        <span class="n">particles</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">-=</span> <span class="mi">90</span><span class="o">*</span><span class="n">DEG</span> <span class="o">+</span> <span class="n">thetanoise</span>
    <span class="k">return</span> <span class="n">particles</span>
</code></pre></div></div><p>The above code should make sense with what is being explained in the rest of the article. The motion update is relatively simple. We take a command in - in this case, it is a string of type: <code class="language-plaintext highlighter-rouge">forward</code>, <code class="language-plaintext highlighter-rouge">backward</code>, <code class="language-plaintext highlighter-rouge">turnleft</code>, or <code class="language-plaintext highlighter-rouge">turnright</code>. Based on that command, all of the particles are updated accordingly. Note, it is really important that you have a different x and y noise. Otherwise, it could end up looking like this (p.s. sorry about taking screenshots instead of saving the images):</p><p><img src="/images/particle-filter/PreviousVersion.gif" alt="path1" class="center-shrink" /></p><p>You can see that the noise is now directly correlated. Hence, why the particles now form a linear arrangement across the map. So watch out for your distributions! Besides that, that is all the code you need for the motion update!</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This is our measurement update
</span><span class="k">def</span> <span class="nf">measurement_update</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">measured_distances</span><span class="p">):</span>
    <span class="c1"># read in our measured distances, just entering this in manually
</span>    <span class="n">z</span> <span class="o">=</span> <span class="n">measured_distances</span>

    <span class="c1"># This is so we can alter how many rays we actually want to use
</span>    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[::</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="n">NUM_OF_RAYS</span><span class="p">]</span>
    <span class="n">nan_location</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="c1"># our weights should all be the same to start
</span>    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">NUM_OF_PARTICLES</span><span class="p">)</span>

    <span class="c1"># again, get the number of particles... could also use a our global variable
</span>    <span class="n">nparticles</span> <span class="o">=</span> <span class="n">particles</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># ok so here let's iterate over the particles
</span>    <span class="k">for</span> <span class="n">particle_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nparticles</span><span class="p">):</span>
        <span class="n">expected_distances</span> <span class="o">=</span> <span class="n">help</span><span class="p">.</span><span class="n">expected_ranges</span><span class="p">(</span><span class="n">particles</span><span class="p">[:,</span><span class="n">particle_index</span><span class="p">],</span> <span class="n">angles_to_use</span><span class="p">,</span> <span class="n">WALL_SEGS</span><span class="p">)</span>
        <span class="n">expected_dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">expected_distances</span><span class="p">)</span>

        <span class="c1"># then we need to iterate over each ray that the particle we're on has seen and compare to the prior 
</span>        <span class="k">for</span> <span class="n">ray_index</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nan_location</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">particle_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">particle_index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">particle_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">particle_index</span><span class="p">]</span> <span class="o">*</span> \
                    <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ray_index</span><span class="p">]</span><span class="o">-</span><span class="n">expected_dist</span><span class="p">[</span><span class="n">ray_index</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">SIGMA_Z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Need to normalize our weights
</span>    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>

    <span class="c1"># these are the particles that we're going to pick from
</span>    <span class="n">particles_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nparticles</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nparticles</span><span class="p">)</span>

    <span class="c1"># get the indices of the surviving particles
</span>    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="n">particles_to_use</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nparticles</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># select the right particles
</span>    <span class="n">particles</span> <span class="o">=</span> <span class="n">particles</span><span class="p">[:,</span><span class="n">indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">particles</span>
</code></pre></div></div><p>This is really where the meat of the problem is. Mathematically, computing these weights or probabilities takes the form:</p>\[w_i = p(z \ | \ x_i ) = \prod_{j=1}^{m} p(z_j \ | \ x_i)\]<p>So here, the \(x_i\) is the particle’s position in the world. \(m\) is the number of beams that are robot is using. Our z_j is some range for a given ray that is shot out from the robot. In this way, we’re looping over every particle, but then the particle’s probability is the product of all the probabilities for the ray. Hence, why this looks like a double for loop when it’s coded up. One for the particles and one for the rays!</p><h1 id="output">Output</h1><p>Here’s an output from our program! Note, we displayed the particles after both the motion and measurement update, that’s kind of why the particles jump around a bit.</p><p><img src="/images/particle-filter/Path1.gif" alt="path1" class="center-shrink" /></p><p>Also ignore the “Iteration” label on the y-axis. I’m just realizing it now, but I don’t want to recreate the gifs again.</p><p>Here’s another path!</p><p><img src="/images/particle-filter/Path2.gif" alt="path2" class="center-shrink" /></p><p>What’s <em>really really <strong>really</strong> cool</em>, is that if you watch carefully, when the particles / Leela get to cell (2,1), they kind of hug the bottom most wall. Well, when we were gathering the sensor data from walking Leela through this maze, she actually swung close to that wall. The robot in the visualization doesn’t reflect Leela’s actual position as she traversed (that would have been cool, but hindsight is 20/20). The robot is solely going to the cells that we programmed in. However, the particles are actually adapting to what happened. They swing closer to the wall based on the <strong>actual</strong> sensor data!! How crazy / cool is that?</p><h1 id="presentation">Presentation</h1><p>Finally, we had to present to the class. The presentation pretty much just included everything that this. You can check out our actual presentation, or in the very least a pdf of our presentation <a href="/pdfs/E28 Final Project - Particle Filter.pdf">here</a>.</p><h1 id="conclusion">Conclusion</h1><p>Ok so first one big lesson learned:</p><center> <strong> visual debugging is awesome and will make your life better. </strong> </center><p>That lesson really got drilled home from Matt after we probably spent an hour trying to debug our code, without realizing that one of the walls we entered was totally incorrect. The other thing that we learned is that genetic algorithms are super interersting. Bayes Theorem has almost limitless applications. Probability is great and I need to learn more. Besides that, it was a really rewarding experience coming up with all of this. As always let me know any comments about my coding style, ways to better my code, corrections to my blog post, etc. Thanks for reading.</p></article><div class="post-content controls__inner"><div class="controls__item prev"> <span>Previous</span> <a href="/2016/sudoku-solver/"> <span> <svg xmlns="http://www.w3.org/2000/svg" width="6" height="11"><path fill="fillColor" d="M5.647 1.718c.37-.434.323-1.09-.106-1.465A1.016 1.016 0 0 0 4.095.36L.25 4.875a1.05 1.05 0 0 0 .017 1.378l3.95 4.407c.38.424 1.03.456 1.448.07a1.05 1.05 0 0 0 .07-1.468l-3.34-3.725 3.253-3.819z"/> </svg> </span> Backtracking Sudoku Solver </a></div><div class="controls__item next"> <span>Next</span> <a href="/2017/simple-sieve-of-eratosthenes/"> A Classic Algorithm - The S... <span> <svg xmlns="http://www.w3.org/2000/svg" width="6" height="11"><path fill="#fillColor" d="M.353 9.282c-.37.434-.323 1.09.106 1.465a1.016 1.016 0 0 0 1.446-.107L5.75 6.125a1.05 1.05 0 0 0-.017-1.378L1.784.34A1.015 1.015 0 0 0 .336.27a1.05 1.05 0 0 0-.07 1.468l3.34 3.725L.353 9.282z"/> </svg> </span> </a></div></div></div><div class="comments"><div class="container"><div class="post-content"><div id="disqus_thread"></div><script> var disqus_config = function () { this.page.url = 'http://localhost:4000/2016/particle-filter/'; this.page.identifier = 'http://localhost:4000/2016/particle-filter/'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://jlarks32.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the comments.</noscript></div></div></div></main><footer class="footer"><div class="container"><nav class="social"> <a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/johnlarkin1"> <svg class="social__icon" viewBox="0 0 20 20" width="20px" height="20px"><path d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg> </a></nav><span>&copy; 2022 Where will you go next?. All rights reserved.</span></div></footer><script async src="/assets/js/bundle.js"></script></body></html>
